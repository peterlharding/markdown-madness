
# PostgreSQL `login_session` Table Design

This document explains how to correctly create a `login_session` table for tracking login sessions in PostgreSQL.

---

## **Original Issues**
Your original SQL had several issues:
- `DEFAULT = 'true'` is invalid syntax. It should be `DEFAULT TRUE` (no `=` or quotes).
- Trailing comma after the last column caused an error.
- `TIMESTAMP` works, but `TIMESTAMPTZ` (timestamp with time zone) is recommended for time zone awareness.
- `SERIAL` is legacy; prefer `GENERATED BY DEFAULT AS IDENTITY`.
- `session_id` should be unique and ideally a `UUID` instead of plain `TEXT`.
- IP address column should be `varchar(45)` to support both IPv4 and IPv6.

---

## **Cleaned-Up Version (Using TEXT for session_id)**

```sql
CREATE TABLE login_session (
    id           integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username     varchar(32)  NOT NULL,
    session_id   text         NOT NULL UNIQUE,
    user_agent   text,
    ip           varchar(45), -- supports IPv4 and IPv6
    created_at   timestamptz  NOT NULL DEFAULT now(),
    last_seen    timestamptz  NOT NULL DEFAULT now(),
    is_active    boolean      NOT NULL DEFAULT TRUE,
    workstation  varchar(32)  NOT NULL
);

-- Helpful indexes
CREATE INDEX idx_login_session_username ON login_session (username);
CREATE INDEX idx_login_session_user_active ON login_session (username, is_active);
```

### Notes
- Use `timestamptz` for time zone-aware timestamps.
- Update `last_seen` in your app whenever a user interacts.

---

## **Preferred Version (Using UUID for session_id)**

If you want `session_id` to be automatically generated as a UUID, enable the `pgcrypto` extension and use `gen_random_uuid()`.

```sql
-- Enable UUID generation functions (run once per database)
CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE login_session (
    id           integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username     varchar(32)  NOT NULL,
    session_id   uuid         NOT NULL DEFAULT gen_random_uuid() UNIQUE,
    user_agent   text,
    ip           varchar(45),
    created_at   timestamptz  NOT NULL DEFAULT now(),
    last_seen    timestamptz  NOT NULL DEFAULT now(),
    is_active    boolean      NOT NULL DEFAULT TRUE,
    workstation  varchar(32)  NOT NULL
);

CREATE INDEX idx_login_session_username ON login_session (username);
CREATE INDEX idx_login_session_user_active ON login_session (username, is_active);
```

---

## **Optional: Enforce One Active Session per User**

To ensure each user has only **one active session**, create a partial unique index:

```sql
CREATE UNIQUE INDEX uniq_active_session_per_user
ON login_session (username)
WHERE is_active = TRUE;
```

This guarantees that there can be at most one active session for each username.

---

## **Summary of Improvements**

| Change                      | Why it matters |
|----------------------------|----------------|
| `DEFAULT TRUE` (no `=` or quotes) | Correct PostgreSQL syntax |
| `timestamptz` instead of `timestamp` | Handles time zones automatically |
| `GENERATED BY DEFAULT AS IDENTITY` | Modern replacement for `SERIAL` |
| `uuid` for session_id | Secure and unique identifier |
| Partial unique index on active sessions | Prevents multiple active sessions per user |

---

## **Recommendations**
- Use **UUIDs** for `session_id` with `gen_random_uuid()` for strong uniqueness.
- Always store `created_at` and `last_seen` as `timestamptz`.
- Enforce one active session per user with a partial unique index if needed.
- Keep the schema simple and add indexes for performance optimization.
